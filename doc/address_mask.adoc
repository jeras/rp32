= Address mask

== Introduction

The aim is to generalize the idea of limiting the address space to less than XLEN address bits.
The address mask would be applied to both the instruction fetch unit (IFU)
program counter (PC) and load/store unit (LSU).
This approach matches the common practice of implementing the system bus with partial decoding of the address.

Advantages:

* The mask cuts off the adder cary propagation from covering the entire XLEN, thus improving timing.
* The masked parts don't require adder logic or flip-flops, thus reducing area.
* The masks do not inherently reduce toggling, but some power savings can be expected
  from the area and timing improvements.

Disadvantages:

* Extra consideration is required to not introduce issues.
  This can be solved with automatic parameter validation for system bus components
  and additionally with `X` propagation for masked address bits during simulation.

Considerations:

* overview of partial decoding approaches,
* review all RISC-V PC related instructions,
* review all RISC-V load/store (memory) instructions,
* review of RISC-V trap handling,
* review of RISC-V memory protection unit (MPU), memory management unit (MMU),
* RISCOF related considerations (tests, reference simulators),
* C compiler considerations (GCC, LVVM, ...).

Implementation:

* Special timing constrains on shared resources (`set_case_analysis`)?

=== Signed/unsigned immediate masked addition

A signed/unsigned immediate `simm`/`uimm` of width `IMMW < XLEN`
is sign/zero extended to create `imm` of width `XLEN`.
This is added to a base value `val` of width `XLEN`
to produce the resulting `sum` of width `XLEN`.
A mask `MASK` of width `XLEN` is used to mask a subset of signals `val`, `imm` and `sum`.

[source,verilog]
----
parameter logic [XLEN-1:0] MASK;

logic unsigned [IMMW-1:0] uimm;
logic   signed [IMMW-1:0] simm;

logic [XLEN-1:0] imm;
logic [XLEN-1:0] val;
logic [XLEN-1:0] sum;

// zero/sign extended immediate
case (signedness)
    UNSIGNED: imm = $unsigned(uimm) = { {XLE-IMMW{1'b0        }}, uimm };
      SIGNED: imm =   $signed(simm) = { {XLE-IMMW{simm[IMMW-1]}}, simm };
endcase
----

[%autowidth]
|===
| `sum` | `val` | `imm` | adder                             | address (or `PC` register)
|       |       |       | `sum = (val        + imm       )` | `addr = sum`
|       |       | MASK  | `sum = (val        + imm & MASK)` | `addr = sum`
|       | MASK  |       | `sum = (val & MASK + imm       )` | `addr = sum`
|       | MASK  | MASK  | `sum = (val & MASK + imm & MASK)` | `addr = sum`
| MASK  |       |       | `sum = (val        + imm       )' | `addr = sum & MASK`
| MASK  |       | MASK  | `sum = (val        + imm & MASK)' | `addr = sum & MASK`
| MASK  | MASK  |       | `sum = (val & MASK + imm       )' | `addr = sum & MASK`
| MASK  | MASK  | MASK  | `sum = (val & MASK + imm & MASK)' | `addr = sum & MASK`
|===

As an universal solution, both operands can be masked,
and additionally the sum would also be masked before being used as an address.

Since adders resources can be shared to operate on different arguments for different instructions,
a mask can add unnecessary resources to an implementation.
Therefore masking both operands and the result might not be the obvious choice for all use cases.

I can't think of a use case, where masking the result of the addition
while converting it into an address (or `PC` register) would require additional resources.

The carry can be prevented from propagating further than bit `[i]`
if for both addition operands bit `[i]` is zero.
Depending on operand values withing the range `[i-1:0]`,
the carry can still propagate into the results bit `[1]`.

All this means a different approach might give better results
depending on whether the immediate is sign or zero extended.
Further research might provide a universal solution,
or it could be possible each RISC-V implementation
would have to go through a set of considerations.

=== RISC-V architecture used for considerations

The architecture used for considerations is using 2 adders (`PC` and `ALU`) to implement all instructions.

All `LOAD`/`STORE` instructions use the `ALU` adder to calculate the data address.
The `PC` adder is used to increment the PC and the instruction address.

All `BRANCH` instructions use the `ALU` adder to calculate the condition for the branch to be taken.
The `PC` adder is used to either increment the PC and the instruction address,
or add the branch offset.

Instructions `JAL`/`JALR` use the `ALU` adder to calculate the jump address and new `PC`.
While the `PC` adder is used to calculate the link address.

This can be seen as a role inversion for the two adders,
the choice was made to be able to have simple `PC` adder
implemented as a RCA with 12 full adders (branch immediate size)
while the remaining XLEN-12 bits are a potentially simpler incrementer/decrementer.

== IFU (PC)

The examples are for a RV32 processor (`XLEN=32`).
The RAM/ROM sizes are similar to small microcontrollers on the market.

The address space used for examples is similar to what RISC-V simulators `spike` and `sail` use.
There is a 4kB ROM at address `0x00000000` and a 64kB RAM at address `0x80000000`.
The reset address is set to `0x00000000`.

NOTE: I was thinking of adding an XIP SPI Flash,
      but those flash devices are in the range of 8MB~128MB,
      so very few address bits would be unused
      thus missing the point of address masking.

.IFU address space
[%autowidth]
|===
| address                     | memory
| `0x00000000` ~ `0x00000fff` | boot ROM 4kB (`2**12`)
| `0x00010000` ~ `0x7fffffff` | boot ROM (`2**(32-1-12)-1` partially decoded copies)
| `0x80000000` ~ `0x8000ffff` | instruction RAM 64kB (`2**16`)
| `0x80010000` ~ `0xffffffff` | instruction RAM (`2**(32-1-16)-1` partially decoded copies)
|===

Two parameters are used to define the reset address and mask.

.IFU parameters
[%autowidth]
|===
| parameter   | value        | description
| `IFU_RESET` | `0x00000000` | IFU reset address, PC reset value
| `IFU_MASK`  | `0x8000FFFF` | IFU address and PC mask
|===

The PC `pc` points to the currently executing instruction `op`.
The IFU address `ifu_addr` points to the next instruction.
The current instruction size in bytes is `ilen`.

The Verilog based pseudocode is a bit simplified,
for example the case where `op` is a branch, the branch is taken.

The IFU address is a combinational assignment.
The PC is synchronously loaded with the IFU address.

[source,verilog]
----
// IFU address
always_comb
case (op)
    JAL    : ifu_addr = pc + imm_j;   // signed offset[20:1]
    JALR   : ifu_addr = rs1 + imm_i;  // signed offset[11:0]
    BRANCH : ifu_addr = pc + imm_b;   // signed offset[12:1]
    TRAP   : ifu_addr = csr_tvec;
    default: ifu_addr = pc + ilen;
endcase

// link GPR
always_ff @(posedge clk)
case (op)
    JAL    : rd <= pc + ilen;
    JALR   : rd <= pc + ilen;
endcase

// xEPC CSR

// program counter
always_ff @(posedge clk, posedge rst)
if (rst) pc <= IFU_RESET;
else     pc <= ifu_addr;
----

=== Instructions incrementing PC by `ILEN`

[source,verilog]
----
assign ifu_addr = pc + ilen;

always_ff @(posedge clk, posedge rst)
if (rst) pc = IFU_RESET
----

== References

QUAD SPI Flash for XIP:
https://www.infineon.com/cms/en/product/memories/nor-flash/serial-nor-flash/quad-spi-flash/

CH32V003 microcontroller:
https://www.wch-ic.com/downloads/CH32V003DS0_PDF.html